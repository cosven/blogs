---
layout: post
title: "每周阅读 2019-10-14 ~ 2019-10-30"
date: 2019-10-30 12:42:29 +00:00
permalink: /blogs/104
tags: [reading, weekly]
categories: [阅读]
---
这个时刻的我其实是特别浮躁的，我看了下自己的阅读记录，上次写这个已经是 9 月初了。

最近一个月，周一到周五都在疯狂工作；周六周末都在疯狂玩游戏，缺少一些总结和思考，自己心里多少也是有点慌的。
最慌的是工作内容，要不趁此机会梳理一下吧，这一个月疯狂工作的成果有些啥？

哎，公司这个 Confluence 是真的破，每次打开都要几十秒...

成果（搬了哪些砖）：

1. bug review -> 结论是 bug 各式各样，无明显共同点。啊，心痛
2. 梳理 bug 字段 + 梳理模块 -> 这个可能还是有一些沉淀把
4. 跟进 longroad 系统发现的 bug -> 说实话，没啥太多收获，主要也是苦力
5. 写回归测试用例和 review 用例 -> 这个部分真的太苦了，唯一让我欣慰的是对整个系统功能有了一个大概的了解
6. OKR 思考 -> 质量体系、bug 发现与重现等主题的思考

哎，自己得加紧学习才行。下面几个技术主题还是挺有意思的，都是自己一直想搞懂的东西。

### dayname 计算方法

今天在 review TiDB bug 的时候，看到一个 dayname 相关的问题，正好看看 TiDB dayname 的实现。
后来发现这个计算能力可能是由语言提供的，于是就去看了下 Python 的实现，感觉挺好玩的。

``` python
def _ymd2ord(year, month, day):
    "year, month, day -> ordinal, considering 01-Jan-0001 as day 1."
    assert 1 <= month <= 12, 'month must be in 1..12'
    dim = _days_in_month(year, month)
    assert 1 <= day <= dim, ('day must be in 1..%d' % dim)
    return (_days_before_year(year) +
            _days_before_month(year, month) +
            day)

(_ymd2ord(year, month, day) + 6) % 7  #  可以算出星期几
```

仔细看代码还可以发现一些有趣的东西：比如 100 年要减一天；400 年要多加一天。知乎上有个相应的问题 [能被4整除的就是闰年吗，为什么？ - TungHsu的回答 - 知乎](https://www.zhihu.com/question/302965980/answer/540456503)

### data race 是个啥？在 golang 中表现是怎样？

参考 [https://stackoverflow.com/a/18049303/4302892](https://stackoverflow.com/a/18049303/4302892)

> The definition of a data race is pretty clear, and therefore, its discovery can be automated. A data race occurs when 2 instructions from different threads access the same memory location, at least one of these accesses is a write and there is no synchronization that is mandating any particular order among these accesses.

看了这个定义，就比较容易理解一个现象：golang 进程因为 data race 而退出。

参考 [https://blog.regehr.org/archives/490](https://blog.regehr.org/archives/490)
race condition: 竞态条件

> A race condition is a flaw that occurs when the timing or ordering of events affects a program’s correctness.

In practice there is considerable overlap: many race conditions are due to data races, and many data races lead to race conditions. On the other hand, we can have race conditions without data races and data races without race conditions.

**附加问题** `critical section` 和两者的关系又是怎样？
参考资料：[http://ifeve.com/race-conditions-and-critical-sections/](http://ifeve.com/race-conditions-and-critical-sections/)

> 当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。
> 导致竞态条件发生的代码区称作临界区。

从这句话，可以推断出，临界区和 data race 是没啥关系的。

### 比较并交换(CAS)

参考资料：https://zh.wikipedia.org/wiki/%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2

CAS 底层原理是怎样的？

> CAS操作基于CPU提供的原子操作指令实现。对于Intel X86处理器，可通过在汇编指令前增加LOCK前缀来锁定系统总线，使系统总线在汇编指令执行时无法访问相应的内存地址。

Nginx 的 CAS 实现（参考[博客](http://www.lenky.info/archives/2012/11/2028)）：

``` c
static ngx_inline ngx_atomic_uint_t
ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,
    ngx_atomic_uint_t set)
{
    u_char  res;
    __asm__ volatile (
         NGX_SMP_LOCK
    "    cmpxchgl  %3, %1;   "
    "    sete      %0;       "
    : "=a" (res) : "m" (*lock), "a" (old), "r" (set) : "cc", "memory");
    return res;
}
```

NGX\_SMP\_LOCK 是指 LOCK 指令，个人不准确的理解：大概意思就是说 LOCK 指令可以保证某一个 CPU 进行这个操作时，其它 CPU 不会干涉它。

> LOCK is not an instruction itself: it is an instruction prefix, which applies to the following instruction. That instruction must be something that does a read-modify-write on memory (INC, XCHG, CMPXCHG etc.) --- in this case it is the incl (%ecx) instruction which increments the long word at the address held in the ecx register.
> 
> The LOCK prefix ensures that the CPU has exclusive ownership of the appropriate cache line for the duration of the operation, and provides certain additional ordering guarantees. This may be achieved by asserting a bus lock, but the CPU will avoid this where possible. If the bus is locked then it is only for the duration of the locked instruction.
> 
> \-\-\- https://stackoverflow\.com/questions/8891067/what\-does\-the\-lock\-instruction\-mean\-in\-x86\-assembly

`cmpxchgl` 指令资料太少，[博客](http://www.lenky.info/archives/2012/11/2028) 讲的似乎是比较清楚地了。

`sete xx` 指令：将标志位 `ZF` 的值放到 xx 中。在上面这段代码里面，相当于是 `sete res` 将 cmpxchql 的结果放到 res 中，表示是否成功。

CAS 应用？

> 在应用中CAS可以用于实现无锁数据结构，常见的有无锁队列(先入先出)[3] 以及无锁堆(先入后出)。


### golang 

#### select

> The select statement lets a goroutine wait on multiple communication operations.
>
> A select blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready.
> 
> --- https://tour.golang.org/concurrency/5