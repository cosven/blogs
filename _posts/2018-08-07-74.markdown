---
layout: post
title: "死锁学习笔记"
date: 2018-08-07 05:53:30 +00:00
permalink: /blogs/74
tags: [Operating System, 死锁, deadlock]
categories: [稍微正经点的]
---
## 学习完的几点个人感受
2. 个人推荐的学习思路
    1. 先看死锁概念和四个必要条件 -> 看 wikipedia
    2. 然后大概的看一下哲学家就餐问题 -> 看 wikipedia
    3. 带着对哲学家问题的疑问，看处理死锁的几种方法 -> 可以看下面给的视频的某些章节
    4. 然后自己梳理死锁（我在下面也有梳理一下）
1. 网上已有博客不是很靠谱：如果对死锁很不了解，推荐看 [这个课程](https://www.coursera.org/learn/os-pku/lecture/ozqyi/zhe-xue-jia-jiu-can-wen-ti) 
   - 课程优点：讲的比较完整，不像博客，看完一堆疑问
   - 课程缺点：视频时间加起来还挺长的，可以针对性的看
2. 进程和线程都会有死锁的现象，也就是说笔记中词语「进程」可以替换为「线程」（除开个别特意声明了他们区别的地方）
3. 不要把 `竞态条件` 和 `死锁` 搞混了（只有多线程才会有竞态条件的概念，进程没有）。
   （这两个概念其实差很远，不过我自己当初确实没搞明白）
4. wikipedia 讲的东西特别有启发/延展性，比如它涉及到 lock-free algorithm，还也很有价值

## 死锁重点知识梳理

- **死锁的概念**：a deadlock is a state in which **each** member of a *group* is waiting for some *other member* to take action, such as sending a message or more commonly releasing a lock
  - 这种情况并不是死锁：A 占有资源 1，B 一直等待资源 1。（B 只是暂时等待而已）
  - 这种情况可以说是死锁：A 进程占了资源 1，B 进程占了资源 2, A 等待资源 2，B 等待资源 1
- 死锁出现的情况
  - 系统资源不足
  - 锁、信号量使用不当
- **死锁出现的四个必要条件**（重要）
  1. 资源互斥
  2. 占有一个资源，等待另外一个资源
  3. 资源不可以被抢占
  4. 有一个循环等待链
- **死锁处理办法**
  - 预防死锁 -> 破坏四个必要条件之一 **静态**
    1. 用一个进程专门管理资源
    2. 一次占有所有资源 / 或者申请失败就释放自己的资源
    3. 允许资源抢占 - 进程优先级
    4. 让资源申请按照一定顺序进行
  - 避免死锁 -> 控制资源分配策略达到避免的效果 **动态**
    - **银行家算法** [zh_wikipedia](https://zh.wikipedia.org/wiki/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95)
- 死锁检测与解除（好像不太重要，方法也挺无脑）
  - 死锁检测方法
  - 死锁接触方法
    - 撤销所有死锁进程
    - 进程回退再启动
- **哲学家就餐问题** [zh_wikipedia](https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98)（重要，贯通整个知识链）

**相关知识**

- 死锁、活锁、饥饿三者区别（重要）
- 资源分配图（用图来帮助分析死锁）
 
## 涉及到的一些概念/经典算法/经典问题
（ps: 这些算法和问题其实都特别容易懂，如果理解了死锁的话）

- 死锁
- 银行家算法
- 哲学家就餐问题